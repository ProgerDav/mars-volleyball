var convnetjs = convnetjs || { REVISION: "ALPHA" }; !function (t) { "use strict"; var s = !1, i = 0, e = function () { if (s) return s = !1, i; var t = 2 * Math.random() - 1, r = 2 * Math.random() - 1, a = t * t + r * r; if (0 == a || a > 1) return e(); var h = Math.sqrt(-2 * Math.log(a) / a); return i = r * h, s = !0, t * h }, r = function (t, s) { return Math.random() * (s - t) + t }, a = function (t, s) { for (var i = 0, e = t.length; i < e; i++)if (t[i] === s) return !0; return !1 }; t.randf = r, t.randi = function (t, s) { return Math.floor(Math.random() * (s - t) + t) }, t.randn = function (t, s) { return t + e() * s }, t.zeros = function (t) { if (void 0 === t || isNaN(t)) return []; if ("undefined" == typeof ArrayBuffer) { for (var s = new Array(t), i = 0; i < t; i++)s[i] = 0; return s } return new Float64Array(t) }, t.maxmin = function (t) { if (0 === t.length) return {}; for (var s = t[0], i = t[0], e = 0, r = 0, a = t.length, h = 1; h < a; h++)t[h] > s && (s = t[h], e = h), t[h] < i && (i = t[h], r = h); return { maxi: e, maxv: s, mini: r, minv: i, dv: s - i } }, t.randperm = function (t) { for (var s, i = t, e = 0, r = [], a = 0; a < t; a++)r[a] = a; for (; i--;)e = Math.floor(Math.random() * (i + 1)), s = r[i], r[i] = r[e], r[e] = s; return r }, t.weightedSample = function (t, s) { for (var i = r(0, 1), e = 0, a = 0, h = t.length; a < h; a++)if (i < (e += s[a])) return t[a] }, t.arrUnique = function (t) { for (var s = [], i = 0, e = t.length; i < e; i++)a(s, t[i]) || s.push(t[i]); return s }, t.arrContains = a, t.getopt = function (t, s, i) { return void 0 !== t[s] ? t[s] : i } }(convnetjs), function (t) { "use strict"; var s = function (s, i, e, r) { if ("[object Array]" === Object.prototype.toString.call(s)) { this.sx = 1, this.sy = 1, this.depth = s.length, this.w = t.zeros(this.depth), this.dw = t.zeros(this.depth); for (var a = 0; a < this.depth; a++)this.w[a] = s[a] } else { this.sx = s, this.sy = i, this.depth = e; var h = s * i * e; if (this.w = t.zeros(h), this.dw = t.zeros(h), void 0 === r) { var o = Math.sqrt(1 / (s * i * e)); for (a = 0; a < h; a++)this.w[a] = t.randn(0, o) } else for (a = 0; a < h; a++)this.w[a] = r } }; s.prototype = { get: function (t, s, i) { var e = (this.sx * s + t) * this.depth + i; return this.w[e] }, set: function (t, s, i, e) { var r = (this.sx * s + t) * this.depth + i; this.w[r] = e }, add: function (t, s, i, e) { var r = (this.sx * s + t) * this.depth + i; this.w[r] += e }, get_grad: function (t, s, i) { var e = (this.sx * s + t) * this.depth + i; return this.dw[e] }, set_grad: function (t, s, i, e) { var r = (this.sx * s + t) * this.depth + i; this.dw[r] = e }, add_grad: function (t, s, i, e) { var r = (this.sx * s + t) * this.depth + i; this.dw[r] += e }, cloneAndZero: function () { return new s(this.sx, this.sy, this.depth, 0) }, clone: function () { for (var t = new s(this.sx, this.sy, this.depth, 0), i = this.w.length, e = 0; e < i; e++)t.w[e] = this.w[e]; return t }, addFrom: function (t) { for (var s = 0; s < this.w.length; s++)this.w[s] += t.w[s] }, addFromScaled: function (t, s) { for (var i = 0; i < this.w.length; i++)this.w[i] += s * t.w[i] }, setConst: function (t) { for (var s = 0; s < this.w.length; s++)this.w[s] = t }, toJSON: function () { var t = {}; return t.sx = this.sx, t.sy = this.sy, t.depth = this.depth, t.w = this.w, t }, fromJSON: function (s) { this.sx = s.sx, this.sy = s.sy, this.depth = s.depth; var i = this.sx * this.sy * this.depth; this.w = t.zeros(i), this.dw = t.zeros(i); for (var e = 0; e < i; e++)this.w[e] = s.w[e] } }, t.Vol = s }(convnetjs), function (t) { "use strict"; var s = t.Vol; t.augment = function (i, e, r, a, h) { void 0 === h && (h = !1); void 0 === r && (r = t.randi(0, i.sx - e)); void 0 === a && (a = t.randi(0, i.sy - e)); var o; if (e !== i.sx || 0 !== r || 0 !== a) { o = new s(e, e, i.depth, 0); for (var n = 0; n < e; n++)for (var u = 0; u < e; u++)if (!(n + r < 0 || n + r >= i.sx || u + a < 0 || u + a >= i.sy)) for (var _ = 0; _ < i.depth; _++)o.set(n, u, _, i.get(n + r, u + a, _)) } else o = i; if (h) { var d = o.cloneAndZero(); for (n = 0; n < o.sx; n++)for (u = 0; u < o.sy; u++)for (_ = 0; _ < o.depth; _++)d.set(n, u, _, o.get(o.sx - n - 1, u, _)); o = d } return o }, t.img_to_vol = function (t, i) { void 0 === i && (i = !1); var e = document.createElement("canvas"); e.width = t.width, e.height = t.height; var r = e.getContext("2d"); try { r.drawImage(t, 0, 0) } catch (t) { if ("NS_ERROR_NOT_AVAILABLE" === t.name) return !1; throw t } try { var a = r.getImageData(0, 0, e.width, e.height) } catch (t) { if ("IndexSizeError" === t.name) return !1; throw t } for (var h = a.data, o = t.width, n = t.height, u = [], _ = 0; _ < h.length; _++)u.push(h[_] / 255 - .5); var d = new s(o, n, 4, 0); if (d.w = u, i) { var l = new s(o, n, 1, 0); for (_ = 0; _ < o; _++)for (var p = 0; p < n; p++)l.set(_, p, 0, d.get(_, p, 0)); d = l } return d } }(convnetjs), function (t) { "use strict"; var s = t.Vol, i = function (t) { t = t || {}; this.out_depth = t.filters, this.sx = t.sx, this.in_depth = t.in_depth, this.in_sx = t.in_sx, this.in_sy = t.in_sy, this.sy = void 0 !== t.sy ? t.sy : this.sx, this.stride = void 0 !== t.stride ? t.stride : 1, this.pad = void 0 !== t.pad ? t.pad : 0, this.l1_decay_mul = void 0 !== t.l1_decay_mul ? t.l1_decay_mul : 0, this.l2_decay_mul = void 0 !== t.l2_decay_mul ? t.l2_decay_mul : 1, this.out_sx = Math.floor((this.in_sx + 2 * this.pad - this.sx) / this.stride + 1), this.out_sy = Math.floor((this.in_sy + 2 * this.pad - this.sy) / this.stride + 1), this.layer_type = "conv"; var i = void 0 !== t.bias_pref ? t.bias_pref : 0; this.filters = []; for (var e = 0; e < this.out_depth; e++)this.filters.push(new s(this.sx, this.sy, this.in_depth)); this.biases = new s(1, 1, this.out_depth, i) }; i.prototype = { forward: function (t, i) { this.in_act = t; for (var e = new s(this.out_sx, this.out_sy, this.out_depth, 0), r = 0; r < this.out_depth; r++)for (var a = this.filters[r], h = -this.pad, o = -this.pad, n = 0; n < this.out_sx; h += this.stride, n++) { o = -this.pad; for (var u = 0; u < this.out_sy; o += this.stride, u++) { for (var _ = 0, d = 0; d < a.sx; d++)for (var l = 0; l < a.sy; l++)for (var p = 0; p < a.depth; p++) { var c = o + l, y = h + d; c >= 0 && c < t.sy && y >= 0 && y < t.sx && (_ += a.w[(a.sx * l + d) * a.depth + p] * t.w[(t.sx * c + y) * t.depth + p]) } _ += this.biases.w[r], e.set(n, u, r, _) } } return this.out_act = e, this.out_act }, backward: function () { var s = this.in_act; s.dw = t.zeros(s.w.length); for (var i = 0; i < this.out_depth; i++)for (var e = this.filters[i], r = -this.pad, a = -this.pad, h = 0; h < this.out_sx; r += this.stride, h++) { a = -this.pad; for (var o = 0; o < this.out_sy; a += this.stride, o++) { for (var n = this.out_act.get_grad(h, o, i), u = 0; u < e.sx; u++)for (var _ = 0; _ < e.sy; _++)for (var d = 0; d < e.depth; d++) { var l = a + _, p = r + u; if (l >= 0 && l < s.sy && p >= 0 && p < s.sx) { var c = (s.sx * l + p) * s.depth + d, y = (e.sx * _ + u) * e.depth + d; e.dw[y] += s.w[c] * n, s.dw[c] += e.w[y] * n } } this.biases.dw[i] += n } } }, getParamsAndGrads: function () { for (var t = [], s = 0; s < this.out_depth; s++)t.push({ params: this.filters[s].w, grads: this.filters[s].dw, l2_decay_mul: this.l2_decay_mul, l1_decay_mul: this.l1_decay_mul }); return t.push({ params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0, l2_decay_mul: 0 }), t }, toJSON: function () { var t = {}; t.sx = this.sx, t.sy = this.sy, t.stride = this.stride, t.in_depth = this.in_depth, t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.l1_decay_mul = this.l1_decay_mul, t.l2_decay_mul = this.l2_decay_mul, t.pad = this.pad, t.filters = []; for (var s = 0; s < this.filters.length; s++)t.filters.push(this.filters[s].toJSON()); return t.biases = this.biases.toJSON(), t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type, this.sx = t.sx, this.sy = t.sy, this.stride = t.stride, this.in_depth = t.in_depth, this.filters = [], this.l1_decay_mul = void 0 !== t.l1_decay_mul ? t.l1_decay_mul : 1, this.l2_decay_mul = void 0 !== t.l2_decay_mul ? t.l2_decay_mul : 1, this.pad = void 0 !== t.pad ? t.pad : 0; for (var i = 0; i < t.filters.length; i++) { var e = new s(0, 0, 0, 0); e.fromJSON(t.filters[i]), this.filters.push(e) } this.biases = new s(0, 0, 0, 0), this.biases.fromJSON(t.biases) } }; var e = function (t) { t = t || {}; this.out_depth = void 0 !== t.num_neurons ? t.num_neurons : t.filters, this.l1_decay_mul = void 0 !== t.l1_decay_mul ? t.l1_decay_mul : 0, this.l2_decay_mul = void 0 !== t.l2_decay_mul ? t.l2_decay_mul : 1, this.num_inputs = t.in_sx * t.in_sy * t.in_depth, this.out_sx = 1, this.out_sy = 1, this.layer_type = "fc"; var i = void 0 !== t.bias_pref ? t.bias_pref : 0; this.filters = []; for (var e = 0; e < this.out_depth; e++)this.filters.push(new s(1, 1, this.num_inputs)); this.biases = new s(1, 1, this.out_depth, i) }; e.prototype = { forward: function (t, i) { this.in_act = t; for (var e = new s(1, 1, this.out_depth, 0), r = t.w, a = 0; a < this.out_depth; a++) { for (var h = 0, o = this.filters[a].w, n = 0; n < this.num_inputs; n++)h += r[n] * o[n]; h += this.biases.w[a], e.w[a] = h } return this.out_act = e, this.out_act }, backward: function () { var s = this.in_act; s.dw = t.zeros(s.w.length); for (var i = 0; i < this.out_depth; i++) { for (var e = this.filters[i], r = this.out_act.dw[i], a = 0; a < this.num_inputs; a++)s.dw[a] += e.w[a] * r, e.dw[a] += s.w[a] * r; this.biases.dw[i] += r } }, getParamsAndGrads: function () { for (var t = [], s = 0; s < this.out_depth; s++)t.push({ params: this.filters[s].w, grads: this.filters[s].dw, l1_decay_mul: this.l1_decay_mul, l2_decay_mul: this.l2_decay_mul }); return t.push({ params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0, l2_decay_mul: 0 }), t }, toJSON: function () { var t = {}; t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.num_inputs = this.num_inputs, t.l1_decay_mul = this.l1_decay_mul, t.l2_decay_mul = this.l2_decay_mul, t.filters = []; for (var s = 0; s < this.filters.length; s++)t.filters.push(this.filters[s].toJSON()); return t.biases = this.biases.toJSON(), t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type, this.num_inputs = t.num_inputs, this.l1_decay_mul = void 0 !== t.l1_decay_mul ? t.l1_decay_mul : 1, this.l2_decay_mul = void 0 !== t.l2_decay_mul ? t.l2_decay_mul : 1, this.filters = []; for (var i = 0; i < t.filters.length; i++) { var e = new s(0, 0, 0, 0); e.fromJSON(t.filters[i]), this.filters.push(e) } this.biases = new s(0, 0, 0, 0), this.biases.fromJSON(t.biases) } }, t.ConvLayer = i, t.FullyConnLayer = e }(convnetjs), function (t) { "use strict"; var s = t.Vol, i = function (s) { s = s || {}; this.sx = s.sx, this.in_depth = s.in_depth, this.in_sx = s.in_sx, this.in_sy = s.in_sy, this.sy = void 0 !== s.sy ? s.sy : this.sx, this.stride = void 0 !== s.stride ? s.stride : 2, this.pad = void 0 !== s.pad ? s.pad : 0, this.out_depth = this.in_depth, this.out_sx = Math.floor((this.in_sx + 2 * this.pad - this.sx) / this.stride + 1), this.out_sy = Math.floor((this.in_sy + 2 * this.pad - this.sy) / this.stride + 1), this.layer_type = "pool", this.switchx = t.zeros(this.out_sx * this.out_sy * this.out_depth), this.switchy = t.zeros(this.out_sx * this.out_sy * this.out_depth) }; i.prototype = { forward: function (t, i) { this.in_act = t; for (var e = new s(this.out_sx, this.out_sy, this.out_depth, 0), r = 0, a = 0; a < this.out_depth; a++)for (var h = -this.pad, o = -this.pad, n = 0; n < this.out_sx; h += this.stride, n++) { o = -this.pad; for (var u = 0; u < this.out_sy; o += this.stride, u++) { for (var _ = -99999, d = -1, l = -1, p = 0; p < this.sx; p++)for (var c = 0; c < this.sy; c++) { var y = o + c, f = h + p; if (y >= 0 && y < t.sy && f >= 0 && f < t.sx) { var v = t.get(f, y, a); v > _ && (_ = v, d = f, l = y) } } this.switchx[r] = d, this.switchy[r] = l, r++ , e.set(n, u, a, _) } } return this.out_act = e, this.out_act }, backward: function () { var s = this.in_act; s.dw = t.zeros(s.w.length); this.out_act; for (var i = 0, e = 0; e < this.out_depth; e++) { this.pad, this.pad; for (var r = 0; r < this.out_sx; this.stride, r++) { -this.pad; for (var a = 0; a < this.out_sy; this.stride, a++) { var h = this.out_act.get_grad(r, a, e); s.add_grad(this.switchx[i], this.switchy[i], e, h), i++ } } } }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.sx = this.sx, t.sy = this.sy, t.stride = this.stride, t.in_depth = this.in_depth, t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.pad = this.pad, t }, fromJSON: function (s) { this.out_depth = s.out_depth, this.out_sx = s.out_sx, this.out_sy = s.out_sy, this.layer_type = s.layer_type, this.sx = s.sx, this.sy = s.sy, this.stride = s.stride, this.in_depth = s.in_depth, this.pad = void 0 !== s.pad ? s.pad : 0, this.switchx = t.zeros(this.out_sx * this.out_sy * this.out_depth), this.switchy = t.zeros(this.out_sx * this.out_sy * this.out_depth) } }, t.PoolLayer = i }(convnetjs), function (t) { "use strict"; t.Vol; var s = function (t) { t = t || {}; this.out_sx = void 0 !== t.out_sx ? t.out_sx : t.in_sx, this.out_sy = void 0 !== t.out_sy ? t.out_sy : t.in_sy, this.out_depth = void 0 !== t.out_depth ? t.out_depth : t.in_depth, this.layer_type = "input" }; s.prototype = { forward: function (t, s) { return this.in_act = t, this.out_act = t, this.out_act }, backward: function () { }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type } }, t.InputLayer = s }(convnetjs), function (t) { "use strict"; var s = t.Vol, i = function (t) { t = t || {}; this.num_inputs = t.in_sx * t.in_sy * t.in_depth, this.out_depth = this.num_inputs, this.out_sx = 1, this.out_sy = 1, this.layer_type = "softmax" }; i.prototype = { forward: function (i, e) { this.in_act = i; for (var r = new s(1, 1, this.out_depth, 0), a = i.w, h = i.w[0], o = 1; o < this.out_depth; o++)a[o] > h && (h = a[o]); var n = t.zeros(this.out_depth), u = 0; for (o = 0; o < this.out_depth; o++) { var _ = Math.exp(a[o] - h); u += _, n[o] = _ } for (o = 0; o < this.out_depth; o++)n[o] /= u, r.w[o] = n[o]; return this.es = n, this.out_act = r, this.out_act }, backward: function (s) { var i = this.in_act; i.dw = t.zeros(i.w.length); for (var e = 0; e < this.out_depth; e++) { var r = -((e === s ? 1 : 0) - this.es[e]); i.dw[e] = r } return -Math.log(this.es[s]) }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.num_inputs = this.num_inputs, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type, this.num_inputs = t.num_inputs } }; var e = function (t) { t = t || {}; this.num_inputs = t.in_sx * t.in_sy * t.in_depth, this.out_depth = this.num_inputs, this.out_sx = 1, this.out_sy = 1, this.layer_type = "regression" }; e.prototype = { forward: function (t, s) { return this.in_act = t, this.out_act = t, t }, backward: function (s) { var i = this.in_act; i.dw = t.zeros(i.w.length); var e = 0; if (s instanceof Array || s instanceof Float64Array) for (var r = 0; r < this.out_depth; r++) { var a = i.w[r] - s[r]; i.dw[r] = a, e += 2 * a * a } else { r = s.dim; var h = s.val; a = i.w[r] - h; i.dw[r] = a, e += 2 * a * a } return e }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.num_inputs = this.num_inputs, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type, this.num_inputs = t.num_inputs } }; var r = function (t) { t = t || {}; this.num_inputs = t.in_sx * t.in_sy * t.in_depth, this.out_depth = this.num_inputs, this.out_sx = 1, this.out_sy = 1, this.layer_type = "svm" }; r.prototype = { forward: function (t, s) { return this.in_act = t, this.out_act = t, t }, backward: function (s) { var i = this.in_act; i.dw = t.zeros(i.w.length); for (var e = i.w[s], r = 0, a = 0; a < this.out_depth; a++)-e + i.w[a] + 1 > 0 && (i.dw[a] += 1, i.dw[s] -= 1, r += -e + i.w[a] + 1); return r }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.num_inputs = this.num_inputs, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type, this.num_inputs = t.num_inputs } }, t.RegressionLayer = e, t.SoftmaxLayer = i, t.SVMLayer = r }(convnetjs), function (t) { "use strict"; var s = t.Vol, i = function (t) { t = t || {}; this.out_sx = t.in_sx, this.out_sy = t.in_sy, this.out_depth = t.in_depth, this.layer_type = "relu" }; i.prototype = { forward: function (t, s) { this.in_act = t; for (var i = t.clone(), e = t.w.length, r = i.w, a = 0; a < e; a++)r[a] < 0 && (r[a] = 0); return this.out_act = i, this.out_act }, backward: function () { var s = this.in_act, i = this.out_act, e = s.w.length; s.dw = t.zeros(e); for (var r = 0; r < e; r++)i.w[r] <= 0 ? s.dw[r] = 0 : s.dw[r] = i.dw[r] }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type } }; var e = function (t) { t = t || {}; this.out_sx = t.in_sx, this.out_sy = t.in_sy, this.out_depth = t.in_depth, this.layer_type = "sigmoid" }; e.prototype = { forward: function (t, s) { this.in_act = t; for (var i = t.cloneAndZero(), e = t.w.length, r = i.w, a = t.w, h = 0; h < e; h++)r[h] = 1 / (1 + Math.exp(-a[h])); return this.out_act = i, this.out_act }, backward: function () { var s = this.in_act, i = this.out_act, e = s.w.length; s.dw = t.zeros(e); for (var r = 0; r < e; r++) { var a = i.w[r]; s.dw[r] = a * (1 - a) * i.dw[r] } }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type } }; var r = function (s) { s = s || {}; this.group_size = void 0 !== s.group_size ? s.group_size : 2, this.out_sx = s.in_sx, this.out_sy = s.in_sy, this.out_depth = Math.floor(s.in_depth / this.group_size), this.layer_type = "maxout", this.switches = t.zeros(this.out_sx * this.out_sy * this.out_depth) }; r.prototype = { forward: function (t, i) { this.in_act = t; var e = this.out_depth, r = new s(this.out_sx, this.out_sy, this.out_depth, 0); if (1 === this.out_sx && 1 === this.out_sy) for (var a = 0; a < e; a++) { for (var h = a * this.group_size, o = t.w[h], n = 0, u = 1; u < this.group_size; u++) { (p = t.w[h + u]) > o && (o = p, n = u) } r.w[a] = o, this.switches[a] = h + n } else for (var _ = 0, d = 0; d < t.sx; d++)for (var l = 0; l < t.sy; l++)for (a = 0; a < e; a++) { for (h = a * this.group_size, o = t.get(d, l, h), n = 0, u = 1; u < this.group_size; u++) { var p; (p = t.get(d, l, h + u)) > o && (o = p, n = u) } r.set(d, l, a, o), this.switches[_] = h + n, _++ } return this.out_act = r, this.out_act }, backward: function () { var s = this.in_act, i = this.out_act, e = this.out_depth; if (s.dw = t.zeros(s.w.length), 1 === this.out_sx && 1 === this.out_sy) for (var r = 0; r < e; r++) { var a = i.dw[r]; s.dw[this.switches[r]] = a } else for (var h = 0, o = 0; o < i.sx; o++)for (var n = 0; n < i.sy; n++)for (r = 0; r < e; r++) { a = i.get_grad(o, n, r); s.set_grad(o, n, this.switches[h], a), h++ } }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.group_size = this.group_size, t }, fromJSON: function (s) { this.out_depth = s.out_depth, this.out_sx = s.out_sx, this.out_sy = s.out_sy, this.layer_type = s.layer_type, this.group_size = s.group_size, this.switches = t.zeros(this.group_size) } }; var a = function (t) { t = t || {}; this.out_sx = t.in_sx, this.out_sy = t.in_sy, this.out_depth = t.in_depth, this.layer_type = "tanh" }; a.prototype = { forward: function (t, s) { this.in_act = t; for (var i, e, r = t.cloneAndZero(), a = t.w.length, h = 0; h < a; h++)r.w[h] = (i = t.w[h], e = void 0, ((e = Math.exp(2 * i)) - 1) / (e + 1)); return this.out_act = r, this.out_act }, backward: function () { var s = this.in_act, i = this.out_act, e = s.w.length; s.dw = t.zeros(e); for (var r = 0; r < e; r++) { var a = i.w[r]; s.dw[r] = (1 - a * a) * i.dw[r] } }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type } }, t.TanhLayer = a, t.MaxoutLayer = r, t.ReluLayer = i, t.SigmoidLayer = e }(convnetjs), function (t) { "use strict"; t.Vol; var s = function (s) { s = s || {}; this.out_sx = s.in_sx, this.out_sy = s.in_sy, this.out_depth = s.in_depth, this.layer_type = "dropout", this.drop_prob = void 0 !== s.drop_prob ? s.drop_prob : .5, this.dropped = t.zeros(this.out_sx * this.out_sy * this.out_depth) }; s.prototype = { forward: function (t, s) { this.in_act = t, void 0 === s && (s = !1); var i = t.clone(), e = t.w.length; if (s) for (var r = 0; r < e; r++)Math.random() < this.drop_prob ? (i.w[r] = 0, this.dropped[r] = !0) : this.dropped[r] = !1; else for (r = 0; r < e; r++)i.w[r] *= this.drop_prob; return this.out_act = i, this.out_act }, backward: function () { var s = this.in_act, i = this.out_act, e = s.w.length; s.dw = t.zeros(e); for (var r = 0; r < e; r++)this.dropped[r] || (s.dw[r] = i.dw[r]) }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t.drop_prob = this.drop_prob, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type, this.drop_prob = t.drop_prob } }, t.DropoutLayer = s }(convnetjs), function (t) { "use strict"; t.Vol; var s = function (t) { t = t || {}; this.k = t.k, this.n = t.n, this.alpha = t.alpha, this.beta = t.beta, this.out_sx = t.in_sx, this.out_sy = t.in_sy, this.out_depth = t.in_depth, this.layer_type = "lrn", this.n % 2 == 0 && console.log("WARNING n should be odd for LRN layer") }; s.prototype = { forward: function (t, s) { this.in_act = t; var i = t.cloneAndZero(); this.S_cache_ = t.cloneAndZero(); for (var e = Math.floor(this.n / 2), r = 0; r < t.sx; r++)for (var a = 0; a < t.sy; a++)for (var h = 0; h < t.depth; h++) { for (var o = t.get(r, a, h), n = 0, u = Math.max(0, h - e); u <= Math.min(h + e, t.depth - 1); u++) { var _ = t.get(r, a, u); n += _ * _ } n *= this.alpha / this.n, n += this.k, this.S_cache_.set(r, a, h, n), n = Math.pow(n, this.beta), i.set(r, a, h, o / n) } return this.out_act = i, this.out_act }, backward: function () { var s = this.in_act; s.dw = t.zeros(s.w.length); this.out_act; for (var i = Math.floor(this.n / 2), e = 0; e < s.sx; e++)for (var r = 0; r < s.sy; r++)for (var a = 0; a < s.depth; a++)for (var h = this.out_act.get_grad(e, r, a), o = this.S_cache_.get(e, r, a), n = Math.pow(o, this.beta), u = n * n, _ = Math.max(0, a - i); _ <= Math.min(a + i, s.depth - 1); _++) { var d = s.get(e, r, _), l = -d * this.beta * Math.pow(o, this.beta - 1) * this.alpha / this.n * 2 * d; _ === a && (l += n), l /= u, l *= h, s.add_grad(e, r, _, l) } }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.k = this.k, t.n = this.n, t.alpha = this.alpha, t.beta = this.beta, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.out_depth = this.out_depth, t.layer_type = this.layer_type, t }, fromJSON: function (t) { this.k = t.k, this.n = t.n, this.alpha = t.alpha, this.beta = t.beta, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.out_depth = t.out_depth, this.layer_type = t.layer_type } }, t.LocalResponseNormalizationLayer = s }(convnetjs), function (t) { "use strict"; var s = t.Vol, i = function (t) { t = t || {}; this.out_sx = t.in_sx, this.out_sy = t.in_sy, this.out_depth = t.in_depth + t.in_depth * t.in_depth, this.layer_type = "quadtransform" }; i.prototype = { forward: function (t, i) { this.in_act = t; for (var e = this.out_depth, r = t.depth, a = new s(this.out_sx, this.out_sy, this.out_depth, 0), h = 0; h < t.sx; h++)for (var o = 0; o < t.sy; o++)for (var n = 0; n < e; n++)if (n < r) a.set(h, o, n, t.get(h, o, n)); else { var u = Math.floor((n - r) / r), _ = n - r - u * r; a.set(h, o, n, t.get(h, o, u) * t.get(h, o, _)) } return this.out_act = a, this.out_act }, backward: function () { var s = this.in_act; s.dw = t.zeros(s.w.length); for (var i = this.out_act, e = this.out_depth, r = s.depth, a = 0; a < s.sx; a++)for (var h = 0; h < s.sy; h++)for (var o = 0; o < e; o++) { var n = i.get_grad(a, h, o); if (o < r) s.add_grad(a, h, o, n); else { var u = Math.floor((o - r) / r), _ = o - r - u * r; s.add_grad(a, h, u, s.get(a, h, _) * n), s.add_grad(a, h, _, s.get(a, h, u) * n) } } }, getParamsAndGrads: function () { return [] }, toJSON: function () { var t = {}; return t.out_depth = this.out_depth, t.out_sx = this.out_sx, t.out_sy = this.out_sy, t.layer_type = this.layer_type, t }, fromJSON: function (t) { this.out_depth = t.out_depth, this.out_sx = t.out_sx, this.out_sy = t.out_sy, this.layer_type = t.layer_type } }, t.QuadTransformLayer = i }(convnetjs), function (t) { "use strict"; t.Vol; var s = function (t) { this.layers = [] }; s.prototype = { makeLayers: function (s) { s.length < 2 && console.log("ERROR! For now at least have input and softmax layers."), "input" !== s[0].type && console.log("ERROR! For now first layer should be input."); s = function () { for (var t = [], i = 0; i < s.length; i++) { var e = s[i]; if ("softmax" !== e.type && "svm" !== e.type || t.push({ type: "fc", num_neurons: e.num_classes }), "regression" === e.type && t.push({ type: "fc", num_neurons: e.num_neurons }), "fc" !== e.type && "conv" !== e.type || void 0 !== e.bias_pref || (e.bias_pref = 0, void 0 !== e.activation && "relu" === e.activation && (e.bias_pref = .1)), void 0 !== e.tensor && e.tensor && t.push({ type: "quadtransform" }), t.push(e), void 0 !== e.activation) if ("relu" === e.activation) t.push({ type: "relu" }); else if ("sigmoid" === e.activation) t.push({ type: "sigmoid" }); else if ("tanh" === e.activation) t.push({ type: "tanh" }); else if ("maxout" === e.activation) { var r = "undefined" !== e.group_size ? e.group_size : 2; t.push({ type: "maxout", group_size: r }) } else console.log("ERROR unsupported activation " + e.activation); void 0 !== e.drop_prob && "dropout" !== e.type && t.push({ type: "dropout", drop_prob: e.drop_prob }) } return t }(), this.layers = []; for (var i = 0; i < s.length; i++) { var e = s[i]; if (i > 0) { var r = this.layers[i - 1]; e.in_sx = r.out_sx, e.in_sy = r.out_sy, e.in_depth = r.out_depth } switch (e.type) { case "fc": this.layers.push(new t.FullyConnLayer(e)); break; case "lrn": this.layers.push(new t.LocalResponseNormalizationLayer(e)); break; case "dropout": this.layers.push(new t.DropoutLayer(e)); break; case "input": this.layers.push(new t.InputLayer(e)); break; case "softmax": this.layers.push(new t.SoftmaxLayer(e)); break; case "regression": this.layers.push(new t.RegressionLayer(e)); break; case "conv": this.layers.push(new t.ConvLayer(e)); break; case "pool": this.layers.push(new t.PoolLayer(e)); break; case "relu": this.layers.push(new t.ReluLayer(e)); break; case "sigmoid": this.layers.push(new t.SigmoidLayer(e)); break; case "tanh": this.layers.push(new t.TanhLayer(e)); break; case "maxout": this.layers.push(new t.MaxoutLayer(e)); break; case "quadtransform": this.layers.push(new t.QuadTransformLayer(e)); break; case "svm": this.layers.push(new t.SVMLayer(e)); break; default: console.log("ERROR: UNRECOGNIZED LAYER TYPE!") } } }, forward: function (t, s) { void 0 === s && (s = !1); for (var i = this.layers[0].forward(t, s), e = 1; e < this.layers.length; e++)i = this.layers[e].forward(i, s); return i }, getCostLoss: function (t, s) { this.forward(t, !1); var i = this.layers.length; return this.layers[i - 1].backward(s) }, backward: function (t) { for (var s = this.layers.length, i = this.layers[s - 1].backward(t), e = s - 2; e >= 0; e--)this.layers[e].backward(); return i }, getParamsAndGrads: function () { for (var t = [], s = 0; s < this.layers.length; s++)for (var i = this.layers[s].getParamsAndGrads(), e = 0; e < i.length; e++)t.push(i[e]); return t }, getPrediction: function () { for (var t = this.layers[this.layers.length - 1].out_act.w, s = t[0], i = 0, e = 1; e < t.length; e++)t[e] > s && (s = t[e], i = e); return i }, toJSON: function () { for (var t = { layers: [] }, s = 0; s < this.layers.length; s++)t.layers.push(this.layers[s].toJSON()); return t }, fromJSON: function (s) { this.layers = []; for (var i = 0; i < s.layers.length; i++) { var e, r = s.layers[i], a = r.layer_type; "input" === a && (e = new t.InputLayer), "relu" === a && (e = new t.ReluLayer), "sigmoid" === a && (e = new t.SigmoidLayer), "tanh" === a && (e = new t.TanhLayer), "dropout" === a && (e = new t.DropoutLayer), "conv" === a && (e = new t.ConvLayer), "pool" === a && (e = new t.PoolLayer), "lrn" === a && (e = new t.LocalResponseNormalizationLayer), "softmax" === a && (e = new t.SoftmaxLayer), "regression" === a && (e = new t.RegressionLayer), "fc" === a && (e = new t.FullyConnLayer), "maxout" === a && (e = new t.MaxoutLayer), "quadtransform" === a && (e = new t.QuadTransformLayer), "svm" === a && (e = new t.SVMLayer), e.fromJSON(r), this.layers.push(e) } } }, t.Net = s }(convnetjs), function (t) { "use strict"; t.Vol; var s = function (t, s) { this.net = t; s = s || {}; this.learning_rate = void 0 !== s.learning_rate ? s.learning_rate : .01, this.l1_decay = void 0 !== s.l1_decay ? s.l1_decay : 0, this.l2_decay = void 0 !== s.l2_decay ? s.l2_decay : 0, this.batch_size = void 0 !== s.batch_size ? s.batch_size : 1, this.method = void 0 !== s.method ? s.method : "sgd", this.momentum = void 0 !== s.momentum ? s.momentum : .9, this.ro = void 0 !== s.ro ? s.ro : .95, this.eps = void 0 !== s.eps ? s.eps : 1e-6, this.k = 0, this.gsum = [], this.xsum = [] }; s.prototype = { train: function (s, i) { var e = (new Date).getTime(); this.net.forward(s, !0); var r = (new Date).getTime() - e, a = (e = (new Date).getTime(), this.net.backward(i)), h = 0, o = 0, n = (new Date).getTime() - e; if (this.k++ , this.k % this.batch_size == 0) { var u = this.net.getParamsAndGrads(); if (0 === this.gsum.length && ("sgd" !== this.method || this.momentum > 0)) for (var _ = 0; _ < u.length; _++)this.gsum.push(t.zeros(u[_].params.length)), "adadelta" === this.method ? this.xsum.push(t.zeros(u[_].params.length)) : this.xsum.push([]); for (_ = 0; _ < u.length; _++)for (var d = u[_], l = d.params, p = d.grads, c = void 0 !== d.l2_decay_mul ? d.l2_decay_mul : 1, y = void 0 !== d.l1_decay_mul ? d.l1_decay_mul : 1, f = this.l2_decay * c, v = this.l1_decay * y, m = l.length, w = 0; w < m; w++) { h += f * l[w] * l[w] / 2, o += v * Math.abs(l[w]); var x = v * (l[w] > 0 ? 1 : -1), g = (f * l[w] + x + p[w]) / this.batch_size, b = this.gsum[_], z = this.xsum[_]; if ("adagrad" === this.method) { b[w] = b[w] + g * g; var S = -this.learning_rate / Math.sqrt(b[w] + this.eps) * g; l[w] += S } else if ("windowgrad" === this.method) { b[w] = this.ro * b[w] + (1 - this.ro) * g * g; S = -this.learning_rate / Math.sqrt(b[w] + this.eps) * g; l[w] += S } else if ("adadelta" === this.method) { b[w] = this.ro * b[w] + (1 - this.ro) * g * g; S = -Math.sqrt((z[w] + this.eps) / (b[w] + this.eps)) * g; z[w] = this.ro * z[w] + (1 - this.ro) * S * S, l[w] += S } else if (this.momentum > 0) { S = this.momentum * b[w] - this.learning_rate * g; b[w] = S, l[w] += S } else l[w] += -this.learning_rate * g; p[w] = 0 } } return { fwd_time: r, bwd_time: n, l2_decay_loss: h, l1_decay_loss: o, cost_loss: a, softmax_loss: a, loss: a + o + h } } }, t.Trainer = s, t.SGDTrainer = s }(convnetjs), function (t) { "use strict"; var s = t.randf, i = t.randi, e = t.Net, r = t.Trainer, a = t.maxmin, h = t.randperm, o = t.weightedSample, n = t.getopt, u = t.arrUnique, _ = function (t, s, i) { i = i || {}; void 0 === t && (t = []), void 0 === s && (s = []), this.data = t, this.labels = s, this.train_ratio = n(i, "train_ratio", .7), this.num_folds = n(i, "num_folds", 10), this.num_candidates = n(i, "num_candidates", 50), this.num_epochs = n(i, "num_epochs", 50), this.ensemble_size = n(i, "ensemble_size", 10), this.batch_size_min = n(i, "batch_size_min", 10), this.batch_size_max = n(i, "batch_size_max", 300), this.l2_decay_min = n(i, "l2_decay_min", -4), this.l2_decay_max = n(i, "l2_decay_max", 2), this.learning_rate_min = n(i, "learning_rate_min", -4), this.learning_rate_max = n(i, "learning_rate_max", 0), this.momentum_min = n(i, "momentum_min", .9), this.momentum_max = n(i, "momentum_max", .9), this.neurons_min = n(i, "neurons_min", 5), this.neurons_max = n(i, "neurons_max", 30), this.folds = [], this.candidates = [], this.evaluated_candidates = [], this.unique_labels = u(s), this.iter = 0, this.foldix = 0, this.finish_fold_callback = null, this.finish_batch_callback = null, this.data.length > 0 && (this.sampleFolds(), this.sampleCandidates()) }; _.prototype = { sampleFolds: function () { var t = this.data.length, s = Math.floor(this.train_ratio * t); this.folds = []; for (var i = 0; i < this.num_folds; i++) { var e = h(t); this.folds.push({ train_ix: e.slice(0, s), test_ix: e.slice(s, t) }) } }, sampleCandidate: function () { var t = this.data[0].w.length, a = this.unique_labels.length, h = []; h.push({ type: "input", out_sx: 1, out_sy: 1, out_depth: t }); for (var n = o([0, 1, 2, 3], [.2, .3, .3, .2]), u = 0; u < n; u++) { var _ = i(this.neurons_min, this.neurons_max), d = ["tanh", "maxout", "relu"][i(0, 3)]; if (s(0, 1) < .5) { var l = Math.random(); h.push({ type: "fc", num_neurons: _, activation: d, drop_prob: l }) } else h.push({ type: "fc", num_neurons: _, activation: d }) } h.push({ type: "softmax", num_classes: a }); var p = new e; p.makeLayers(h); var c, y = i(this.batch_size_min, this.batch_size_max), f = Math.pow(10, s(this.l2_decay_min, this.l2_decay_max)), v = Math.pow(10, s(this.learning_rate_min, this.learning_rate_max)), m = s(this.momentum_min, this.momentum_max), w = s(0, 1), x = new r(p, c = w < .33 ? { method: "adadelta", batch_size: y, l2_decay: f } : w < .66 ? { method: "adagrad", learning_rate: v, batch_size: y, l2_decay: f } : { method: "sgd", learning_rate: v, momentum: m, batch_size: y, l2_decay: f }), g = { acc: [], accv: 0 }; return g.layer_defs = h, g.trainer_def = c, g.net = p, g.trainer = x, g }, sampleCandidates: function () { this.candidates = []; for (var t = 0; t < this.num_candidates; t++) { var s = this.sampleCandidate(); this.candidates.push(s) } }, step: function () { this.iter++; for (var t = this.folds[this.foldix], s = t.train_ix[i(0, t.train_ix.length)], a = 0; a < this.candidates.length; a++) { var h = this.data[s], o = this.labels[s]; this.candidates[a].trainer.train(h, o) } var n = this.num_epochs * t.train_ix.length; if (this.iter >= n) { var u = this.evalValErrors(); for (a = 0; a < this.candidates.length; a++) { (_ = this.candidates[a]).acc.push(u[a]), _.accv += u[a] } if (this.iter = 0, this.foldix++ , null !== this.finish_fold_callback && this.finish_fold_callback(), this.foldix >= this.folds.length) { for (a = 0; a < this.candidates.length; a++)this.evaluated_candidates.push(this.candidates[a]); this.evaluated_candidates.sort(function (t, s) { return t.accv / t.acc.length > s.accv / s.acc.length ? -1 : 1 }), this.evaluated_candidates.length > 3 * this.ensemble_size && (this.evaluated_candidates = this.evaluated_candidates.slice(0, 3 * this.ensemble_size)), null !== this.finish_batch_callback && this.finish_batch_callback(), this.sampleCandidates(), this.foldix = 0 } else for (a = 0; a < this.candidates.length; a++) { var _ = this.candidates[a], d = new e; d.makeLayers(_.layer_defs); var l = new r(d, _.trainer_def); _.net = d, _.trainer = l } } }, evalValErrors: function () { for (var t = [], s = this.folds[this.foldix], i = 0; i < this.candidates.length; i++) { for (var e = this.candidates[i].net, r = 0, a = 0; a < s.test_ix.length; a++) { var h = this.data[s.test_ix[a]], o = this.labels[s.test_ix[a]]; e.forward(h), r += e.getPrediction() === o ? 1 : 0 } r /= s.test_ix.length, t.push(r) } return t }, predict_soft: function (t) { var s, i, e = Math.min(this.ensemble_size, this.evaluated_candidates.length); if (0 === e) return new convnetjs.Vol(0, 0, 0); for (var r = 0; r < e; r++) { var a = this.evaluated_candidates[r].net.forward(t); if (0 === r) s = a, i = a.w.length; else for (var h = 0; h < i; h++)s.w[h] += a.w[h] } for (h = 0; h < i; h++)s.w[h] /= i; return s }, predict: function (t) { var s = this.predict_soft(t); if (0 !== s.w.length) var i = a(s.w).maxi; else i = -1; return i }, toJSON: function () { for (var t = Math.min(this.ensemble_size, this.evaluated_candidates.length), s = { nets: [] }, i = 0; i < t; i++)s.nets.push(this.evaluated_candidates[i].net.toJSON()); return s }, fromJSON: function (t) { this.ensemble_size = t.nets.length, this.evaluated_candidates = []; for (var s = 0; s < this.ensemble_size; s++) { var i = new e; i.fromJSON(t.nets[s]); var r = {}; r.net = i, this.evaluated_candidates.push(r) } }, onFinishFold: function (t) { this.finish_fold_callback = t }, onFinishBatch: function (t) { this.finish_batch_callback = t } }, t.MagicNet = _ }(convnetjs), function (t) { "use strict"; "undefined" == typeof module || void 0 === module.exports ? window.jsfeat = t : module.exports = t }(convnetjs);